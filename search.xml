<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Github</title>
      <link href="/2022/10/29/Github%E5%90%8C%E6%AD%A5fork%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/10/29/Github%E5%90%8C%E6%AD%A5fork%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Github同步fork项目"><a href="#Github同步fork项目" class="headerlink" title="Github同步fork项目"></a>Github同步fork项目</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在<a href="https://so.csdn.net/so/search?q=github&amp;spm=1001.2101.3001.7020">github</a>上fork了一个项目，之后原作者又更新了内容，想把原作者更新的内容同步到fork的项目仓库中，以下是同步步骤。</p><h2 id="同步步骤"><a href="#同步步骤" class="headerlink" title="同步步骤"></a>同步步骤</h2><p>首先打开自己fork后的项目的主页，点击Pull <a href="https://so.csdn.net/so/search?q=requests&amp;spm=1001.2101.3001.7020">requests</a>，再点击New pull request</p><p><a href="https://images.xcnv.com/2022/10/29/635d2cbc0f32a.jpg"><img src="https://images.xcnv.com/2022/10/29/635d2cbc0f32a.jpg" alt="b2cf9a1a3aa172f7208155752dfd03c.jpg"></a></p><p>把上图中的base repository和head repository互换位置</p><p><a href="https://images.xcnv.com/2022/10/29/635d2cdbc0a28.jpg"><img src="https://images.xcnv.com/2022/10/29/635d2cdbc0a28.jpg" alt="580894b66e778dc9da2bb8bb86b04fd.jpg"></a></p><p><a href="https://images.xcnv.com/2022/10/29/635d2cf0be569.jpg"><img src="https://images.xcnv.com/2022/10/29/635d2cf0be569.jpg" alt="b7d53374328b155613fd8a21f85bcb4.jpg"></a></p><p>按照以上步骤操作之后，会出现下图的页面</p><p><a href="https://images.xcnv.com/2022/10/29/635d2d93ddb4a.jpg"><img src="https://images.xcnv.com/2022/10/29/635d2d93ddb4a.jpg" alt="ed24d531811aebb3208b622287f442e.jpg"></a></p><p><a href="https://images.xcnv.com/2022/10/29/635d2d95aa4a1.jpg"><img src="https://images.xcnv.com/2022/10/29/635d2d95aa4a1.jpg" alt="d87521b9350c40b26c8571951122c9c.jpg"></a></p><p>点击Create pull request</p><p><a href="https://images.xcnv.com/2022/10/29/635d2d97d8fcb.jpg"><img src="https://images.xcnv.com/2022/10/29/635d2d97d8fcb.jpg" alt="cf34f7a8df18f4e09ef5f806e33b5f1.jpg"></a></p><p>填写好标题后点击Create pull request即可同步原作者更新</p><p><a href="https://images.xcnv.com/2022/10/29/635d2d99f2db1.jpg"><img src="https://images.xcnv.com/2022/10/29/635d2d99f2db1.jpg" alt="8b69633766863cf55fcea1cfe053e73.jpg"></a></p><p>如果没有同步的话，手动点击Merge pull request即可</p><p><a href="https://images.xcnv.com/2022/10/29/635d2d9c1ca1e.jpg"><img src="https://images.xcnv.com/2022/10/29/635d2d9c1ca1e.jpg" alt="6a88ffa0925ce0baba63f3ca4336f07.jpg"></a></p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2022/09/24/2022-09-24-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/24/2022-09-24-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>贪心算法，又名贪婪算法。以下棋为例，每步的决策都需要考虑对后续棋局的影响。而在网球（或排球）比赛中，选手的行为仅取决于当前的状况，选择当下最为正确的动作，而不关心后续的影响 这说明在某些情况下选择当下最佳行为的决策，可以得到一个最优解（贪婪），但并非所有情况都如此，贪婪策略适用于上述第二类问题。即将问题分为多个阶段，在每一个阶段，选取当前状态下的最优决策，而不考虑对后续决策的影响。这意味着算法在执行过程中会选取某些局部最优解。贪婪假设通过局部最优解可以获得全局最优解。</p><h2 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h2><p>最优贪婪算法需要满足两个基本性质 ：</p><ul><li><p>贪婪选择性质。 </p></li><li><p>最优子结构</p></li></ul><p><strong>贪婪选择性质：</strong> 全局最优解可以通过寻找局部最优解获得（贪婪），局部最优解的 </p><p>择可能依赖于之前的决策，而不是后续的决策 通过迭代方式算法进行 个个贪婪选择， </p><p>将原问题简化为规模更小的问题 </p><p><strong>最优子结构：</strong> 如果原问题的最优解包含子问题的最优解，则认为该问题具有最优子</p><p>结构。这意味着可以对子问题求解并构建规模更大问题的解。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>通过一系列选择步骤来构造问题的解，每一步都是对当前部分解的一个扩展，直至获得问题的完整解。所做的每一步选择都必须满足:</p><ol><li><p><strong>可行的</strong>:必须满足问题的约束。</p></li><li><p><strong>局部最优</strong>:当前所有可能的选择中最佳的局部选择。</p></li><li><p><strong>不可取消</strong>:选择一旦做出，在后面的步骤中就无法改变了。</p></li></ol><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ol><li><p>不能保证总能得到最优解（一系列的局部最优选择不能保证最后得到整体最优解）</p></li><li><p>不能用来求最大值或最小值问题</p></li><li><p>只能求满足某些约束条件的可行解的范围。</p></li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点是</strong>直观，易于理解，并易于编码实现。当前的决策不会对已经计算出的结果有任何影响，因此不需要再对已有的局部解进行检查。</p><p><strong>缺点是</strong>，对于许多问题，无法用贪婪算法求解。即在许多情况下，无法保证局部最优解能够产生全局最优解</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li><p>排序问题：选择排序、拓扑排序 </p></li><li><p>优先队列：堆排序 </p></li><li><p>赫夫曼编码压缩算法 </p></li><li><p>Prim和 Krukal 算法 </p></li><li><p>加权图的最短路径问题（ stra 算法） </p></li><li><p>硬币找零问题 </p></li><li><p>分数背包问题 </p></li><li><p>并查集的按大小或高度合并问题（或排名） </p></li><li><p>任务调度算法 </p></li><li><p>贪婪算法可用于求解复杂问题的近似算法。</p></li></ul><h2 id="实际生活例子"><a href="#实际生活例子" class="headerlink" title="实际生活例子"></a>实际生活例子</h2><p><strong>找钱问题</strong>:</p><p>设有4种硬币，面值分别为25分，10分，5分和1分，要找出63分钱，问如何找钱可使得找出的硬币个数最少？</p><p>63=25+25+10+1+1+1</p><p><strong>另一个找钱问题</strong>:</p><p>设有3种硬币，面值分别为25分，10分和1分，要找出30分钱，问如何找钱可使得找出的硬币个数最少?</p><p>分析：如使用贪心算法：30分钱，在面值25分，10分和1分找出最优为25分，然后进行下一步，只能选面值为1分的硬币，故以贪心算法最终算得的硬币数为6个。并不如3个面值为10分的个数少。故不可使用贪心算法。</p><p>30=25+1+1+1+1+1  六个硬币</p><p>30=10+10+10          三个硬币</p><h1 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h1><h2 id="LeetCode1710-卡车上的最大单元数"><a href="#LeetCode1710-卡车上的最大单元数" class="headerlink" title="LeetCode1710. 卡车上的最大单元数"></a><strong>LeetCode1710. 卡车上的最大单元数</strong></h2><p>请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi] ：</p><p><strong>numberOfBoxesi 是类型 i 的箱子的数量。</strong></p><p><strong>numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。</strong></p><p>整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。</p><p>返回卡车可以装载 单元 的 最大 总数。</p><pre class=" language-Plain"><code class="language-Plain">示例 1：输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4输出：8解释：箱子的情况如下：- 1 个第一类的箱子，里面含 3 个单元。- 2 个第二类的箱子，每个里面含 2 个单元。- 3 个第三类的箱子，每个里面含 1 个单元。可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8示例 2：输入：boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10输出：91提示：1 <= boxTypes.length <= 10001 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 10001 <= truckSize <= 106</code></pre><p><strong>思路：</strong></p><p>题目要求的是：</p><p>boxTypes 是二维数组 ，其中 boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi] ：</p><p>numberOfBoxesi 是类型 i 的箱子的数量。</p><p>numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。</p><p>只要箱子数量不超过 truckSize，尽可能多的 以装载 单元 的 ，</p><p>换个思路就是说，numberOfBoxesi 表示有多少个箱子，numberOfUnitsPerBoxi，箱子的大小是多少个，但是题目给的是箱子的上限，所以，我们的是不是可以理解，只要箱子越大（也就是某一类的箱子可以装载的单元越多），就可以装更多的单元，所以我们根据 numberOfUnitsPerBoxi （每个箱子的大小）进行排序</p><p><a href="https://images.xcnv.com/2022/10/29/635d29bd69742.jpg"><img src="https://images.xcnv.com/2022/10/29/635d29bd69742.jpg" alt="1916902e54961d317a36692de50ab52.jpg"></a></p><h4 id="初始代码模板"><a href="#初始代码模板" class="headerlink" title="初始代码模板"></a><strong>初始代码模板</strong></h4><pre class=" language-Java"><code class="language-Java">class Solution {    public int maximumUnits(int[][] boxTypes, int truckSize) {    }}class Solution {    public int maximumUnits(int[][] boxTypes, int truckSize) {        Arrays.sort(boxTypes, (o1, o2) -> o2[1] - o1[1]);                int ans = 0;        for (int i = 0; i < boxTypes.length; i++) {            if (truckSize > boxTypes[i][0]) {                ans += boxTypes[i][0] * boxTypes[i][1];                truckSize -= boxTypes[i][0];            } else {                ans += truckSize * boxTypes[i][1];                break;            }        }        return ans;    }}</code></pre><h2 id="LeetCode455-分发饼干"><a href="#LeetCode455-分发饼干" class="headerlink" title="LeetCode455. 分发饼干"></a><strong>LeetCode455. 分发饼干</strong></h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code>。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><pre class=" language-Java"><code class="language-Java">示例 1:输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。示例 2:输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 提示：1 <= g.length <= 3 * 10(4)0 <= s.length <= 3 * 10(4)1 <= g[i], s[j] <= 2(31) - 1</code></pre><p><strong>思路</strong></p><p>大尺寸饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p><p><strong>局部最优</strong>：大尺寸饼干先喂饱胃口大的，充分利用饼干尺寸。 </p><p><strong>全局最优</strong>：喂饱尽可能多的小孩。 尝试贪心算法添加链接描述，先把饼干数组和小孩数组排序。然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><p><a href="https://images.xcnv.com/2022/10/29/635d29bdd4962.jpg"><img src="https://images.xcnv.com/2022/10/29/635d29bdd4962.jpg" alt="132968dcb94405a7dc3c8002f1241c8.jpg"></a></p><pre class=" language-Java"><code class="language-Java">class Solution {    public int findContentChildren(int[] g, int[] s) {        Arrays.sort(g);        Arrays.sort(s);        int count = 0;        int start = s.length-1;        for(int index = g.length-1; index >= 0; index--){            if(start >= 0 && g[index] <= s[start]){                start--;                count++;            }        }        return count;     }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图数据建模基础</title>
      <link href="/2022/07/30/My-New-Post/"/>
      <url>/2022/07/30/My-New-Post/</url>
      
        <content type="html"><![CDATA[<h1 id="1-入门"><a href="#1-入门" class="headerlink" title="1 入门"></a>1 入门</h1><h2 id="1-1-模块概述"><a href="#1-1-模块概述" class="headerlink" title="1.1 模块概述"></a>1.1 模块概述</h2><p>在本模块中，您将了解：</p><ul><li><p>什么是图数据建模。</p></li><li><p>领域知识对建模的重要性。</p></li><li><p>图数据模型和实例模型之间的区别。</p></li></ul><h2 id="1-2-什么是图数据建模？"><a href="#1-2-什么是图数据建模？" class="headerlink" title="1.2 什么是图数据建模？"></a>1.2 什么是图数据建模？</h2><h3 id="为什么要建模？"><a href="#为什么要建模？" class="headerlink" title="为什么要建模？"></a>为什么要建模？</h3><p>如果您要使用 Neo4j 图来支持部分或全部应用程序，则必须与利益相关者协作设计一个图形，该图形将：</p><ul><li><p>回答应用程序的关键用例。</p></li><li><p>为关键用例提供最佳的 Cypher 语句属性。</p></li></ul><h3 id="Neo4j-图的组件"><a href="#Neo4j-图的组件" class="headerlink" title="Neo4j 图的组件"></a>Neo4j 图的组件</h3><p>用于定义图形数据模型的Neo4j组件包括：</p><ul><li><p>节点 Nodes</p></li><li><p>标签 Labels</p></li><li><p>关系 Relationships</p></li><li><p>属性 Properties</p></li></ul><h3 id="数据建模过程"><a href="#数据建模过程" class="headerlink" title="数据建模过程"></a>数据建模过程</h3><p>以下是创建图形数据模型的步骤：</p><ol><li><p>了解领域并为应用程序定义特定用例（问题）。</p></li><li><p>开发初始图形数据模型：</p><ol><li><p>对<strong>节点（实体）</strong> 进行建模。</p></li><li><p>对节点之间的<strong>关系</strong>进行建模。</p></li></ol></li><li><p>针对初始数据模型测试用例。</p></li><li><p>使用 Cypher 创建包含测试数据的图形（<strong>实例</strong>模型）。</p></li><li><p>测试用例，包括针对图形的属性。</p></li><li><p>由于关键用例的更改或性能原因，重构（改进）图形数据模型。</p></li><li><p>在图上实现重构并使用 Cypher 重新测试。</p></li></ol><p>图形数据建模是一个迭代过程。您的初始图形数据模型是一个起点，但随着您对用例的更多信息或用例发生变化，初始图形数据模型将需要更改。此外，您可能会发现，尤其是在图形缩放时，您需要修改图形（<strong>重构</strong>）以实现关键用例的最佳性能。</p><p>重构在开发过程中<strong>非常普遍</strong>。Neo4j图有一个非常灵活的可选模式，这与RDBMS中的模式不同。Cypher 开发人员可以轻松修改图形以表示改进的数据模型。</p><h2 id="1-3-领域"><a href="#1-3-领域" class="headerlink" title="1.3 领域"></a>1.3 领域</h2><h3 id="了解应用程序的领域"><a href="#了解应用程序的领域" class="headerlink" title="了解应用程序的领域"></a>了解应用程序的领域</h3><p>在开始数据建模过程之前，您必须：</p><ul><li><p>确定应用程序的利益干系人和开发人员。</p></li><li><p>与利益相关者和开发人员：</p><ul><li><p>详细描述应用程序。</p></li><li><p>确定应用程序的用户（人员、系统）。</p></li><li><p>就应用程序的用例达成一致。</p></li><li><p>对用例的重要性进行排名。</p></li></ul></li></ul><h3 id="电影领域"><a href="#电影领域" class="headerlink" title="电影领域"></a>电影领域</h3><p>在<a href="https://graphacademy.neo4j.com/courses/neo4j-fundamentals/" title="Neo4j Fundamentals课程中">Neo4j Fundamentals课程中</a>，您被介绍给一个“入门”电影图谱。</p><p>该领域包括电影、演员或导演以及为电影评分的用户。使这个领域变得有趣的是图中节点之间的连接或关系。</p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>应用程序的大多数用例都可以通过一个完整的问题列表来枚举。这些用例有助于定义应用程序在运行时的行为方式。</p><p>以下是您将使用来开发初始图形数据模型的用例：</p><ol><li><p>人们在电影中演了什么？</p></li><li><p>哪个人导演了一部电影？</p></li><li><p>一个人演了什么电影？</p></li><li><p>有多少用户对一部电影进行了评分？</p></li><li><p>谁是演电影的最年轻的人？</p></li><li><p>一个人在电影中扮演了什么角色？</p></li><li><p>根据互联网电影数据库的数据，特定年份评分最高的电影是什么？</p></li><li><p>演员演过什么电影？</p></li><li><p>哪些用户给电影的评分为5？</p></li></ol><p>在我们的领域中，我们希望将出演或导演过电影的人与为电影评分的用户或评论者区分开来。我们有更多关于人们的信息，例如他们的出生日期，他们的tmdbId等。对电影进行评级的用户只会被命名或识别。</p><h2 id="1-4-模型的用途"><a href="#1-4-模型的用途" class="headerlink" title="1.4 模型的用途"></a>1.4 模型的用途</h2><h3 id="模型类型"><a href="#模型类型" class="headerlink" title="模型类型"></a>模型类型</h3><p>为应用程序执行图形数据建模过程时，至少需要两种类型的模型：</p><ul><li><p>数据模型</p></li><li><p>实例模型</p></li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型描述图形的标签、关系和属性。它没有将在图形中创建的特定数据。</p><p>下面是一个数据模型示例：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/1-getting-started/3-purpose-of-model/images/sample-data-model.png"></p><p>没有任何东西可以唯一标识具有给定标签的节点。但是，图形数据模型很重要，因为它定义了在应用程序创建和使用图形时将用于标签、关系类型和属性的名称。</p><h3 id="建模的规范指南"><a href="#建模的规范指南" class="headerlink" title="建模的规范指南"></a>建模的规范指南</h3><p>在开始图形数据建模过程时，请务必就标签、关系类型和属性键的<strong>命名方式达成一致</strong>。标签、关系类型和属性键<strong>区分大小写</strong>，这与不区分大小写的 Cypher 关键字不同。</p><p>Neo4j的最佳实践是在命名图形元素时使用以下方法，但您可以自由地为您的应用程序使用任何约定。</p><ul><li><p>标签是以大写字母开头的单个标识符，可以是<a href="https://en.wikipedia.org/wiki/Camel_case" title="驼峰大小写">驼峰大小写</a>。CamelCase.</p><ul><li>示例：Person、Company、GitHubRepo</li></ul></li><li><p><strong>关系类型是所有大写字母中带有下划线字符</strong>的单个标识符。</p><ul><li>示例：FOLLOWS、MARRIED_TO</li></ul></li><li><p><strong>节点或关系的属性键是单个标识符，它以小写字母开头，</strong> 可以是<a href="https://en.wikipedia.org/wiki/Camel_case" title="驼峰大小写">驼峰大小写</a>。CamelCase.</p><ul><li>示例：deptId、firstName</li></ul></li></ul><p><strong>注</strong>： 属性键名称不必是唯一的。例如，“<em>Person”节点和</em>“<em>Movie</em>”_节点，每个节点都可以具有 <em>tmdbId</em> 的属性键。</p><h3 id="实例模型"><a href="#实例模型" class="headerlink" title="实例模型"></a>实例模型</h3><p>图形数据建模过程的一个重要部分是针对用例测试模型。为此，您需要有一组示例数据，您可以使用这些数据来查看是否可以用模型来回答用例。</p><p>下面是一个实例模型的示例：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/1-getting-started/3-purpose-of-model/images/sample-data-instance-model.png"></p><p>在此实例模型中，我们创建了“<em>Person</em>”和“<em>Movie</em>”节点的一些实例及其关系。拥有这种类型的实例模型将有助于用于测试我们的用例。</p><h1 id="2-节点建模"><a href="#2-节点建模" class="headerlink" title="2 节点建模"></a>2 节点建模</h1><h2 id="2-1-模块概述"><a href="#2-1-模块概述" class="headerlink" title="2.1 模块概述"></a>2.1 模块概述</h2><p>在本模块中，您将了解：</p><ul><li><p>从您的使用案例中<strong>识别实体</strong>。</p></li><li><p>在图形中<strong>创建节点</strong>以支持数据模型。</p></li></ul><h2 id="2-2-建模节点"><a href="#2-2-建模节点" class="headerlink" title="2.2 建模节点"></a>2.2 建模节点</h2><h3 id="定义标签"><a href="#定义标签" class="headerlink" title="定义标签"></a>定义标签</h3><p>实体是应用程序用例中的主要名词：</p><ol><li><p><strong>食谱</strong>中使用了哪些<strong>成分</strong>？</p></li><li><p>谁嫁给了<strong>这个人</strong>？</p></li></ol><p>您的用例的实体将是图形数据模型中标记的节点。</p><p>在 Movie 域中，我们在用例中使用<strong>名词</strong>来定义标签，例如：</p><ol><li><p><strong>人们</strong>在<strong>电影</strong>中演了什么？</p></li><li><p>哪个<strong>人</strong>导演了一<strong>部电影</strong>？</p></li><li><p>一个<strong>人</strong>演了什么<strong>电影</strong>？</p></li></ol><p>以下是我们将开始使用的一些标记节点。</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/2-defining-nodes/1-defining-nodes/images/movie-person-labels.png"></p><p>请注意，这里我们使用 CamelCase 作为标签的名称。</p><h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>节点属性用于：</p><ul><li><p>唯一标识节点。</p></li><li><p>回答应用程序用例的具体细节。</p></li><li><p>返回数据。</p></li></ul><p>例如，在 Cypher 语句中，属性用于：</p><ul><li><p>锚点（开始查询的位置）。</p><ul><li><code>MATCH (p:Person {name: 'Tom Hanks'})-[:ACTED_IN]-(m:Movie) RETURN m</code></li></ul></li><li><p>遍历图形（导航）。</p><ul><li><code>MATCH (p:Person)-[:ACTED_IN]-(m:Movie {title: 'Apollo 13'})-[:RATED]-(u:User) RETURN p,u</code></li></ul></li><li><p>从查询返回数据。</p><ul><li><code>MATCH (p:Person {name: 'Tom Hanks'})-[:ACTED_IN]-(m:Movie) RETURN m.title, m.released</code></li></ul></li></ul><h3 id="“影片”图表中的唯一标识符"><a href="#“影片”图表中的唯一标识符" class="headerlink" title="“影片”图表中的唯一标识符"></a>“影片”图表中的唯一标识符</h3><p>在 <em>Movie</em> 图中，我们使用以下属性来唯一标识节点：</p><ul><li><p>Person.tmdbId</p></li><li><p>Movie.tmdbId</p></li></ul><h3 id="节点的属性"><a href="#节点的属性" class="headerlink" title="节点的属性"></a>节点的属性</h3><p>除了用于唯一标识节点的 <em>tmdbId</em> 之外，我们还必须重新访问用例以确定节点必须保存的数据类型。</p><p>以下是我们将重点介绍的特定于 _“人物”<em>和</em>“电影”_节点的用例列表。这些用例告诉我们_电影_和_人物_节点中所需的数据。</p><table><thead><tr><th><strong>用例</strong></th><th><strong>所需步骤</strong></th></tr></thead><tbody><tr><td>1：电影中有哪些人演戏？&amp;#xA;What people acted in a movie?</td><td>1.  按<strong>title</strong>检索电影。&amp;#xA;2.  返回参与者的<strong>names</strong>。</td></tr><tr><td>2：哪个人导演了一部电影？&amp;#xA;What person directed a movie?</td><td>1.  按<strong>title</strong>检索电影。&amp;#xA;2.  返回导演的<strong>name</strong>。</td></tr><tr><td>3： 一个人演了什么电影？&amp;#xA;What movies did a person act in?</td><td>1.  按<strong>name</strong>检索人员 **。**&amp;#xA;2.  返回影片的**titles **。</td></tr><tr><td>5： 谁是演电影的最年轻的人？&amp;#xA;Who was the youngest person to act in a movie?</td><td>1.  按<strong>title</strong>检索电影。&amp;#xA;2.  评估演员的<strong>ages</strong>。&amp;#xA;3.  返回参与者的<strong>name</strong>。</td></tr><tr><td>7： 根据imDB的数据，特定年份评分最高的电影是什么？&amp;#xA;What is the highest rated movie in a particular year according to imDB?</td><td>1.  检索特定年份<strong>released</strong>的所有电影。&amp;#xA;2.  评估<strong>imDB ratings</strong>。&amp;#xA;3.  返回影片<strong>title</strong>。</td></tr><tr><td>8： 演员演了什么剧情片？&amp;#xA;What drama movies did an actor act in?</td><td>1.  按<strong>name</strong>检索参与者。&amp;#xA;2.  评估演员所演电影的<strong>genres</strong>。&amp;#xA;3.  返回影片<strong>titles</strong>。</td></tr></tbody></table><p>鉴于这些用例的步骤的详细信息，以下是我们将为 <em>Movie</em> 节点定义的属性：</p><ul><li><p>电影标题（字符串）Movie.title (string)</p></li><li><p>电影发行（日期）Movie.released (date)</p></li><li><p>电影评级（0-10之间的小数）Movie.imdbRating (decimal between 0-10)</p></li><li><p>电影流派（字符串列表）Movie.genres (list of strings)</p></li></ul><p>以下是我们将为 <em>Person</em> 节点定义的属性：</p><ul><li><p>Person.name（string）</p></li><li><p>Person.born (date)</p></li><li><p>Person.died (date)</p></li></ul><p>注意：_died_的属性将是可选的。</p><p>下面是初始数据模型：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/2-defining-nodes/1-defining-nodes/images/before-challenge1-data-model.png"></p><p>下面是您将要创建的初始实例模型：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/2-defining-nodes/1-defining-nodes/images/before-challenge1-instance-model.png"></p><h2 id="2-3-创建节点"><a href="#2-3-创建节点" class="headerlink" title="2.3 创建节点"></a>2.3 创建节点</h2><p>这里在网页的右侧直接可以输入cypher语句进行尝试</p><p>以下是您将要使用的初始实例模型：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/2-defining-nodes/2-c-creating-initial-nodes/images/before-challenge1-instance-model.png"></p><p>运行下面的 Cypher 代码，将“人物”和“电影”节点添加到图形中，这将用作我们的初始实例模型：</p><p>运行查询。</p><pre class=" language-cypher"><code class="language-cypher">MATCH (n) DETACH DELETE n;MERGE (:Movie {title: 'Apollo 13', tmdbId: 568, released: '1995-06-30', imdbRating: 7.6, genres: ['Drama', 'Adventure', 'IMAX']})MERGE (:Person {name: 'Tom Hanks', tmdbId: 31, born: '1956-07-09'})MERGE (:Person {name: 'Meg Ryan', tmdbId: 5344, born: '1961-11-19'})MERGE (:Person {name: 'Danny DeVito', tmdbId: 518, born: '1944-11-17'})MERGE (:Person {name: 'Jack Nicholson', tmdbId: 514, born: '1937-04-22'})MERGE (:Movie {title: 'Sleepless in Seattle', tmdbId: 858, released: '1993-06-25', imdbRating: 6.8, genres: ['Comedy', 'Drama', 'Romance']})MERGE (:Movie {title: 'Hoffa', tmdbId: 10410, released: '1992-12-25', imdbRating: 6.6, genres: ['Crime', 'Drama']})</code></pre><p>注意，在此代码中，我们使用 Neo4j 最佳实践指南来命名标签 （CamelCase） 和属性（camelCase）。</p><p>您可以通过运行以下代码来验证是否已创建节点：</p><pre class=" language-cypher"><code class="language-cypher">MATCH (n) RETURN n</code></pre><p>共有 7 个节点。</p><h2 id="2-4-标识新标签"><a href="#2-4-标识新标签" class="headerlink" title="2.4 标识新标签"></a>2.4 标识新标签</h2><p>我们需要为一个新的用例重构模型：</p><p><strong>用例#4：有多少用户对一部电影进行了评分？</strong></p><p>我们已经为我们的用例确定了 _“人物”<em>和</em>“电影”_节点：</p><ul><li><p>What <strong>people</strong> acted in a <strong>movie</strong>?</p></li><li><p>What <strong>person</strong> directed a <strong>movie</strong>?</p></li><li><p>What <strong>movies</strong> did a <strong>person</strong> act in?</p></li></ul><p>以下是我们当前的图形数据模型：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/2-defining-nodes/3-c-defining-nodes/images/before-challenge1-data-model.png"></p><p>我们还有一个必须建模的附加用例。我们需要能够将评级网站用户与其他类型的演员和导演区分开来。</p><p><strong>注意</strong>：在学习本课程时，您可以使用任何想要的技术来绘制图形数据模型。大多数人只使用笔和纸。</p><p>测验：<strong>向模型添加新标签</strong></p><p>应向节点添加什么<strong>标签</strong>以标识已对电影进行评分的任何<strong>用户</strong>？</p><p>What <strong>label</strong> should be added to nodes to identify any <strong>Users</strong> who have rated a movie?</p><ul><li><p>提示</p><p>我们正在寻找一个字符串，该字符串定义了一个标签，可用于查找代表我们数据库中<strong>用户</strong>的任何节点。</p><p>我们已经定义了 <em>“电影”</em> 和“<em>人物”标签</em>。我们希望将电影评分的网站<strong>用户</strong>与出演或导演过电影<strong>的用户</strong>区分开来。</p><p>另请注意，在本课程中，我们将使用CamelCase作为标签名称的标准。也就是说，标签将以大写字母开头。</p><p>答案是： User</p></li></ul><p>在本次挑战中，您展示了为图形数据模型识别附加标签的技能。</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/2-defining-nodes/3-c-defining-nodes/images/after-challenge1-data-model.png"></p><p>在下一个挑战中，您将演示如何在图中创建具有新标签和属性的节点。</p><h2 id="2-5-创建更多节点"><a href="#2-5-创建更多节点" class="headerlink" title="2.5 创建更多节点"></a>2.5 创建更多节点</h2><p>我们想在图中添加几个用户节点，以便我们可以测试对模型的更改。</p><p>任何User节点都将具有以下属性：</p><ul><li><p>userId - an integer (eg. <code>123</code>)</p></li><li><p>name - a string (eg. <code>User’s Name</code>)</p></li></ul><p>创建两个用户节点：</p><ol><li><p>‘Sandy Jones’ with the userId of 534</p></li><li><p>‘Clinton Spencer’ with the userId of 105</p></li></ol><pre class=" language-cypher"><code class="language-cypher">MERGE (u:User {userId: 123})SET u.name = "User's Name"</code></pre><p>修改 Sandbox 窗口中的 MERGE 语句以在数据库中查找或创建两个用户。<br>您可以在一个查询中创建两个节点，也可以在两个单独的查询中创建节点。</p><pre class=" language-cypher"><code class="language-cypher">MERGE (u:User {userId: 534})SET u.name = 'Sandy Jones'MERGE (m:User {userId: 105})SET m.name = 'Clinton Spencer'</code></pre><p>在这个挑战中，您展示了您可以创建一些节点来支持您的实例模型。</p><p>您的实例模型现在应该如下所示：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/2-defining-nodes/4-c-creating-nodes/images/after-challenge2-instance-model.png"></p><p>在下一个模块中，您将学习如何向模型添加关系。</p><h1 id="3-关系建模"><a href="#3-关系建模" class="headerlink" title="3 关系建模"></a>3 关系建模</h1><h2 id="3-1模块概述"><a href="#3-1模块概述" class="headerlink" title="3.1模块概述"></a>3.1模块概述</h2><p>在本模块中，您将了解：</p><ul><li><p>从您的使用案例中识别关系。</p></li><li><p>在关系图中创建关系以支持数据模型。</p></li></ul><h2 id="3-2建模关系"><a href="#3-2建模关系" class="headerlink" title="3.2建模关系"></a>3.2建模关系</h2><h3 id="关系是实体之间的连接"><a href="#关系是实体之间的连接" class="headerlink" title="关系是实体之间的连接"></a>关系是实体之间的连接</h3><p>连接是您的用例中的<strong>动词</strong>：</p><ul><li><p>食谱<strong>中使用</strong>了哪些成分？</p></li><li><p>谁<strong>嫁给了</strong>这个人？</p></li></ul><p>乍一看，连接很简单，但它们的微观和宏观设计可以说是图形性能中最关键的因素。使用“连接是动词”是入门的一个很好的速记，但在本课程的后面部分，您将了解其他重要的注意事项。</p><h3 id="命名关系"><a href="#命名关系" class="headerlink" title="命名关系"></a>命名关系</h3><p>为图形中的关系选择好的名称（类型）非常重要。关系类型需要对利益干系人和开发人员都直观。关系类型不能与实体名称混淆。</p><p>因此，在我们的示例用例中，我们可以定义以下关系类型：</p><ul><li><p>使用</p></li><li><p>已婚</p></li></ul><p>请注意，我们使用Neo4j最佳实践，所有大写字母/下划线字符作为关系的名称。</p><h3 id="关系方向"><a href="#关系方向" class="headerlink" title="关系方向"></a>关系方向</h3><p>在 Neo4j 中创建关系时，必须显式指定方向，或者通过指定模式中的从左到右的方向推断方向。在运行时，在查询期间，通常不需要方向。</p><p>在上面显示的示例用例中，必须创建 <strong>USES</strong> 关系才能从 Recipe 节点转到 Ingredient 节点。</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/3-defining-relationships/1-defining-relationships/images/uses.png"></p><p>可以创建<strong>已婚</strong>关系以从任一节点开始，因为这种类型的关系是对称的。</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/3-defining-relationships/1-defining-relationships/images/married.png"></p><p>关系通常介于 2 个不同的节点之间，但也可以是同一节点。</p><h3 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h3><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/3-defining-relationships/1-defining-relationships/images/fanout.png"></p><p>在这里，我们有实体（个人，住所）表示不是单个节点，而是网络或链接节点。</p><p>这是扇出的一个极端例子，对于任何现实生活中的解决方案来说，几乎肯定是过分的，但是一定程度的扇出可能非常有用。</p><p>例如，将姓氏拆分到单独的节点上有助于回答“谁的姓氏为 Scott？”这个问题。同样，将城市作为单独的节点有助于解决“谁与帕特里克·斯科特住在同一个城市？”的问题。</p><p>扇出的主要风险是它可能导致非常密集的节点或超级节点。这些是具有数十万个传入或传出关系的节点，超级节点需要仔细处理。</p><h3 id="“影片”图形中的关系"><a href="#“影片”图形中的关系" class="headerlink" title="“影片”图形中的关系"></a>“影片”图形中的关系</h3><p>现在，让我们看一下如何识别这些用例的关系：</p><ul><li><p>人们在电影中<strong>演了</strong>什么？</p></li><li><p>哪个人<strong>导演了</strong>一部电影？</p></li><li><p>一个人<strong>演</strong>了什么电影？</p></li></ul><p>给定这些用例，我们将关系命名为：</p><ul><li><p>ACTED_IN</p></li><li><p>指示</p></li></ul><p>此外，这两种关系类型都从 _“人”<em>节点开始，到</em>“影片”_节点结束。</p><p>以下是支持的图形数据模型：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/3-defining-relationships/1-defining-relationships/images/adding-first-relationships.png"></p><p>下面是支持此图形数据模型的实例模型：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/3-defining-relationships/1-defining-relationships/images/adding-first-relationships-instance.png"></p><p>汤姆·汉克斯出演了两部电影。梅格·瑞安（Meg Ryan）和杰克·尼科尔森（Jack Nicholson）各自出演了一部电影。丹尼·德维托（Danny DeVito）都出演并执导了同一部电影。通过探索与此实例模型的关系，我们看到电影阿波罗 13 号在图中只有一个演员，但另外两部电影各有两个演员。</p><h3 id="关系的属性"><a href="#关系的属性" class="headerlink" title="关系的属性"></a>关系的属性</h3><p>关系的属性用于丰富两个节点之间的关系。当您为关系定义属性时，这是因为您的用例会询问有关两个节点如何相关的特定问题，而不仅仅是它们是否相关。</p><p>例如，我们在_Neo4j基础_课程中看到，可以将属性添加到关系中以进一步描述它。</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/3-defining-relationships/1-defining-relationships/images/relationship-properties.jpg"></p><p>在这里，我们看到我们在_已婚_关系上有一个_日期_属性，以进一步描述迈克尔和莎拉之间的关系。此外，我们在_WORKS_AT_关系上有一个_角色_属性，用于描述 Michael 在 Graph Inc. 工作时拥有或拥有的角色。</p><p>这些属性特定于两个节点之间的关系。</p><h3 id="影片图表中的关系属性"><a href="#影片图表中的关系属性" class="headerlink" title="影片图表中的关系属性"></a>影片图表中的关系属性</h3><p>就像您分析命名标签、关系类型和节点属性的用例一样，您可以使用这些用例来提出关系的属性。</p><p>下面是一个用例：</p><ol><li><strong>一个人在电影中扮演了什么角色？</strong></li></ol><p>此用例的运行时操作包括：</p><ol><li><p>检索人员的姓名。</p></li><li><p>遵循与电影ACTED_IN关系。</p></li><li><p>按标题筛选影片。</p></li><li><p>从两个节点之间的ACTED_IN关系返回<strong>角色</strong>。</p></li></ol><p>我们知道，对于此用例，特定_ACTED_IN_关系_的角色_是必需的。因此，我们将_角色_属性添加到此关系中。下面是数据模型：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/3-defining-relationships/1-defining-relationships/images/before-challenge1-data-model.png"></p><p>下面是您将要创建的实例模型：</p><p><img src="https://graphacademy.neo4j.com/courses/modeling-fundamentals/3-defining-relationships/1-defining-relationships/images/before-challenge1-instance-model.png"></p><p>此处的每个_ACTED_IN_关系对_角色_属性都有不同的值。</p>]]></content>
      
      
      <categories>
          
          <category> Neo4j </category>
          
      </categories>
      
      
        <tags>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/27/hello-world/"/>
      <url>/2022/07/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
